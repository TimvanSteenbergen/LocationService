// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package flatfileinterface.actions;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.apache.commons.io.FileUtils;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import flatfileinterface.proxies.LogMessageType;
import flatfileinterface.proxies.ProcesFileQueue;
import flatfileinterface.shared.LogFactory;
import flatfileinterface.shared.LogMsg;
import flatfileinterface.shared.LogObject;
import flatfileinterface.shared.Shared;

public class ExecuteInterface_FixedLength_4_1_00 extends CustomJavaAction<java.lang.String>
{
	private IMendixObject __interfaceDefinition;
	private flatfileinterface.proxies.InterfaceDefinition interfaceDefinition;
	private java.util.List<IMendixObject> __columnList;
	private java.util.List<flatfileinterface.proxies.ColumnDefinition> columnList;
	private java.lang.String importDirectory;
	private java.lang.String fileExtension;
	private java.lang.Boolean skipFirstLine;
	private IMendixObject __logObject;
	private flatfileinterface.proxies.Log logObject;
	private java.lang.Boolean renameFile;
	private java.util.List<IMendixObject> __inputQueuedFiles;
	private java.util.List<flatfileinterface.proxies.ProcesFileQueue> inputQueuedFiles;
	private java.lang.String fileEncoding;

	public ExecuteInterface_FixedLength_4_1_00(IContext context, IMendixObject interfaceDefinition, java.util.List<IMendixObject> columnList, java.lang.String importDirectory, java.lang.String fileExtension, java.lang.Boolean skipFirstLine, IMendixObject logObject, java.lang.Boolean renameFile, java.util.List<IMendixObject> inputQueuedFiles, java.lang.String fileEncoding)
	{
		super(context);
		this.__interfaceDefinition = interfaceDefinition;
		this.__columnList = columnList;
		this.importDirectory = importDirectory;
		this.fileExtension = fileExtension;
		this.skipFirstLine = skipFirstLine;
		this.__logObject = logObject;
		this.renameFile = renameFile;
		this.__inputQueuedFiles = inputQueuedFiles;
		this.fileEncoding = fileEncoding;
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		this.interfaceDefinition = __interfaceDefinition == null ? null : flatfileinterface.proxies.InterfaceDefinition.initialize(getContext(), __interfaceDefinition);

		this.columnList = new java.util.ArrayList<flatfileinterface.proxies.ColumnDefinition>();
		if (__columnList != null)
			for (IMendixObject __columnListElement : __columnList)
				this.columnList.add(flatfileinterface.proxies.ColumnDefinition.initialize(getContext(), __columnListElement));

		this.logObject = __logObject == null ? null : flatfileinterface.proxies.Log.initialize(getContext(), __logObject);

		this.inputQueuedFiles = new java.util.ArrayList<flatfileinterface.proxies.ProcesFileQueue>();
		if (__inputQueuedFiles != null)
			for (IMendixObject __inputQueuedFilesElement : __inputQueuedFiles)
				this.inputQueuedFiles.add(flatfileinterface.proxies.ProcesFileQueue.initialize(getContext(), __inputQueuedFilesElement));

		// BEGIN USER CODE
		/* @author E.P. 't Hoen
		 * @version 14 March 2014
		 * 05-03-2013
		 * v2.2.01
		 * Skip column function added
		 * 11-11-2013
		 * v3.0.00
		 * 07-03-2014
		 * v4.0.00
		 * Added transaction management
		 * Added extra try finally block for file handlers
		 * 14-03-2014
		 * v4.0.01 - v4.1.03
		 * Incorporated the create entity function directly into the read function
		 * Changed logging so that column numbers can been shown next to the line numbers
		 * as the intermediary objects are no longer created
		 * Moved shared functions to the shared folder
		 * Removed datainputstream as this was not needed
		 * Changed filerenamer as this does not need to return files
		 * 05-09-2016
		 * v5.0.0
		 * Added support for decimal attributes
		 */
		String uID = UUID.randomUUID().toString();
		String strLine;
		String splitarray[] = new String[columnList.size()];
		List<IMendixObject> importedObjects = new ArrayList<IMendixObject>();
		boolean triggerEvents = interfaceDefinition.getTriggerEventsOnCommit();
		boolean logToConsole = interfaceDefinition.getLogToConsole();
		LogFactory lf = new LogFactory();
		LogObject logObj = lf.InitLoggers();
		ILogNode logger = Core.getLogger(LOGNODE);
		IContext context = getContext();

		int batchSize= interfaceDefinition.getBatchSize();

		if(!interfaceDefinition.getUseQueue()){
			try {
				File folder = new File(importDirectory.replace("\\", "\\\\"));
				if(folder.isDirectory()){
					//Only read files with the extensions in the array
					String[] extensions = {fileExtension};
					List<File> listOfFiles = (List<File>) FileUtils.listFiles(folder, extensions, true);
					//check if files with the extension are available in the directory
					if(listOfFiles.size() != 0){

						//Start processing the files from the directory
						for (int i = 0; i < listOfFiles.size(); i++) {
							File file = listOfFiles.get(i);
							if (file.isFile()) {
								InputStreamReader fstream = new InputStreamReader(new FileInputStream(listOfFiles.get(i)), fileEncoding);
								BufferedReader br = new BufferedReader(fstream);
								try {
									int lineNum = 1;
									// skip the first line if indicated via the configuration
									if(skipFirstLine){
										br.readLine();
										lineNum++;
									}
									IContext newContext =getContext().getSession().createContext();
									newContext.startTransaction();
									logger.debug("Start import");
									while ((strLine = br.readLine()) != null)   {
										lineNum++;
										for(int j =0, n=columnList.size(); j<n; j++){
											int startPos = columnList.get(j).getStartPosition();
											int EndPos = columnList.get(j).getEndPosition();
											try {
												splitarray[j]= strLine.substring(startPos,EndPos);
											} catch (Exception e) {
												logger.debug("Error on setting value for column");
												LogMsg logMsg = logObj.getMsgByID(10);
												logMsg.setLines(lineNum-1);

											}
										}
										Shared.CreateEntity(interfaceDefinition.getMappedEntity(newContext), interfaceDefinition.getTriggerEventsOnCommit(newContext), splitarray, columnList,String.valueOf(lineNum-1), newContext, logObject, importedObjects, logToConsole, logObj);

										if (importedObjects.size()>batchSize) {
											Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
										}
									}
									if (importedObjects.size()> 0) {
										Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
									}
									logger.debug("End import");
									newContext.endTransaction();
									br.close();
									/* Rename the processed file by adding a datetimestamp to the extension
									 * This will make the processed files unique
									 */
									if(renameFile){
										Shared.changeFileExtension(file,RENAME_EXTENSION, logObject, newContext, logToConsole);
									}
									fstream.close();
									/*
									 * Log errors if existing
									 */
									lf.WriteLogs(logObj, logObject, context, logToConsole, logger);
								} catch (Exception e) {
									try {
										Shared.CreateLogMessage(LogMessageType.Error, "General in the method", e.getMessage(),logObject, context,logToConsole);
									} catch (CoreException ec) {
										ec.printStackTrace();
									}
								} finally{
									if(br != null){
										br.close();
									}
									if(fstream != null){
										fstream.close();
									}
								}
							} 
						}

					}
					else{
						try {
							Shared.CreateLogMessage(LogMessageType.Warning, "No files found in "+importDirectory+" with file extension "+ fileExtension, "",logObject, context,logToConsole);
						} catch (CoreException ec) {
							ec.printStackTrace();
						}
					}
				}
				else{
					try {
						Shared.CreateLogMessage(LogMessageType.Error, "Import directory "+importDirectory+" not found", "",logObject, context,logToConsole);
					} catch (CoreException ec) {
						ec.printStackTrace();
					}
				}
			} catch (Exception e) {
				try {
					Shared.CreateLogMessage(LogMessageType.Error, "General error on reading files (common causes: defined fixed lengths do not match file content or access error due to cloud security settings)", e.getMessage(),logObject, context,logToConsole);
				} catch (CoreException ec) {
					ec.printStackTrace();
				}
			}
		}else{
			try {
				//Start processing the files from the queue
				for (int i = 0; i < inputQueuedFiles.size(); i++) {
					ProcesFileQueue file = inputQueuedFiles.get(i);
					InputStream fstream = Core.getFileDocumentContent(context, file.getMendixObject());
					BufferedReader br = new BufferedReader(new InputStreamReader(fstream));
					try {
						int lineNum = 1;
						// skip the first line if indicated via the configuration
						if(skipFirstLine){
							br.readLine();
							lineNum++;
						}
						IContext newContext =getContext().getSession().createContext();
						newContext.startTransaction();
						logger.debug("Start import");
						while ((strLine = br.readLine()) != null)   {
							lineNum++;
							logger.debug("Reading line "+ (lineNum-1));
							/* Process the columns for the current file and create column objects
							 * Column objects are stored in a list to relate to the line object
							 */
							for(int j =0, n=columnList.size(); j<n; j++){
								int startPos = columnList.get(j).getStartPosition();
								int EndPos = columnList.get(j).getEndPosition();
								try {
									splitarray[j]= strLine.substring(startPos,EndPos);
								} catch (Exception e) {
									logger.debug("Error on setting value for column");
									file.setError(true);
									file.commit();
									LogMsg logMsg = logObj.getMsgByID(10);
									logMsg.setLines(lineNum-1);

								}
							}
							Shared.CreateEntity(interfaceDefinition.getMappedEntity(newContext), interfaceDefinition.getTriggerEventsOnCommit(newContext), splitarray, columnList,String.valueOf(lineNum-1), newContext, logObject, importedObjects, logToConsole, logObj);
							if (importedObjects.size()>batchSize) {
								Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
							}
						}
						if (importedObjects.size()> 0) {
							Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
						}
						logger.debug("End import");
						newContext.endTransaction();
						br.close();
						/* 
						 * Set the file as processed
						 */
						file.setProcessed(true);
						file.commit();
						fstream.close();
						/*
						 * Log errors if existing
						 */
						lf.WriteLogs(logObj, logObject, context, logToConsole, logger);
					} catch (Exception e) {
						try {
							Shared.CreateLogMessage(LogMessageType.Error, "General in the method", e.getMessage(),logObject, context,logToConsole);
						} catch (CoreException ec) {
							ec.printStackTrace();
						}
					} finally{
						if(br != null){
							br.close();
						}
						if(fstream != null){
							fstream.close();
						}
					}
				}
			} catch (Exception e) {
				try {
					Shared.CreateLogMessage(LogMessageType.Error, "General error on reading queued files", e.getMessage(),logObject, context,logToConsole);
				} catch (CoreException ec) {
					ec.printStackTrace();
				}
			}
		}
		return uID;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "ExecuteInterface_FixedLength_4_1_00";
	}

	// BEGIN EXTRA CODE
	private static final String RENAME_EXTENSION = "bak";
	private static final String LOGNODE = "FFI Import";
	// END EXTRA CODE
}
