// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package flatfileinterface.actions;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.apache.commons.io.FileUtils;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import flatfileinterface.proxies.LogMessageType;
import flatfileinterface.proxies.ProcesFileQueue;
import flatfileinterface.shared.LogFactory;
import flatfileinterface.shared.LogMsg;
import flatfileinterface.shared.LogObject;
import flatfileinterface.shared.Shared;

public class ExecuteInterface_Delimited_4_1_00 extends CustomJavaAction<java.lang.String>
{
	private IMendixObject __interfaceDefinition;
	private flatfileinterface.proxies.InterfaceDefinition interfaceDefinition;
	private java.util.List<IMendixObject> __columnList;
	private java.util.List<flatfileinterface.proxies.ColumnDefinition> columnList;
	private java.lang.String Delimiter;
	private java.lang.String importDirectory;
	private java.lang.String fileExtension;
	private java.lang.Boolean skipFirstLine;
	private IMendixObject __logObject;
	private flatfileinterface.proxies.Log logObject;
	private java.lang.Boolean renameFile;
	private java.util.List<IMendixObject> __inputQueuedFiles;
	private java.util.List<flatfileinterface.proxies.ProcesFileQueue> inputQueuedFiles;
	private java.lang.String fileEncoding;

	public ExecuteInterface_Delimited_4_1_00(IContext context, IMendixObject interfaceDefinition, java.util.List<IMendixObject> columnList, java.lang.String Delimiter, java.lang.String importDirectory, java.lang.String fileExtension, java.lang.Boolean skipFirstLine, IMendixObject logObject, java.lang.Boolean renameFile, java.util.List<IMendixObject> inputQueuedFiles, java.lang.String fileEncoding)
	{
		super(context);
		this.__interfaceDefinition = interfaceDefinition;
		this.__columnList = columnList;
		this.Delimiter = Delimiter;
		this.importDirectory = importDirectory;
		this.fileExtension = fileExtension;
		this.skipFirstLine = skipFirstLine;
		this.__logObject = logObject;
		this.renameFile = renameFile;
		this.__inputQueuedFiles = inputQueuedFiles;
		this.fileEncoding = fileEncoding;
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		this.interfaceDefinition = __interfaceDefinition == null ? null : flatfileinterface.proxies.InterfaceDefinition.initialize(getContext(), __interfaceDefinition);

		this.columnList = new java.util.ArrayList<flatfileinterface.proxies.ColumnDefinition>();
		if (__columnList != null)
			for (IMendixObject __columnListElement : __columnList)
				this.columnList.add(flatfileinterface.proxies.ColumnDefinition.initialize(getContext(), __columnListElement));

		this.logObject = __logObject == null ? null : flatfileinterface.proxies.Log.initialize(getContext(), __logObject);

		this.inputQueuedFiles = new java.util.ArrayList<flatfileinterface.proxies.ProcesFileQueue>();
		if (__inputQueuedFiles != null)
			for (IMendixObject __inputQueuedFilesElement : __inputQueuedFiles)
				this.inputQueuedFiles.add(flatfileinterface.proxies.ProcesFileQueue.initialize(getContext(), __inputQueuedFilesElement));

		// BEGIN USER CODE
		/* @author E.P. 't Hoen
		 * @version 14 March 2014
		 * 05-03-2013
		 * v2.2.01
		 * Skip column function added
		 * 11-11-2013
		 * v3.0.00
		 * 07-03-2014
		 * v4.0.00
		 * Added transaction management
		 * Added extra try finally block for file handlers
		 * 14-03-2014
		 * v4.0.01 - v4.1.03
		 * Incorporated the create entity function directly into the read function
		 * Changed logging so that column numbers can been shown next to the line numbers
		 * as the intermediary objects are no longer created
		 * Moved shared functions to the shared folder
		 * Removed datainputstream as this was not needed
		 * Changed filerenamer as this does not need to return files
		 */
		String uID = UUID.randomUUID().toString();
		List<IMendixObject> importedObjects = new ArrayList<IMendixObject>();
		boolean triggerEvents = interfaceDefinition.getTriggerEventsOnCommit();
		boolean logToConsole = interfaceDefinition.getLogToConsole();
		LogFactory lf = new LogFactory();
		LogObject logObj = lf.InitLoggers();
		ILogNode logger = Core.getLogger(LOGNODE);
		IContext context = getContext();

		int batchSize= interfaceDefinition.getBatchSize();

		if(!interfaceDefinition.getUseQueue()){
			try {
				File folder = new File(importDirectory.replace("\\", "\\\\"));
				if(folder.isDirectory()){
					//Only read files with the extensions in the array
					String[] extensions = {fileExtension};
					List<File> listOfFiles = (List<File>) FileUtils.listFiles(folder, extensions, true);
					//check if files with the extension are available in the directory
					if(listOfFiles.size() != 0){
						String strLine;
						String splitarray[] = null;
						//Start processing the files from the directory
						for (int i = 0; i < listOfFiles.size(); i++) {
							File file = listOfFiles.get(i);
							if (file.isFile()) {
								InputStreamReader fstream = new InputStreamReader(new FileInputStream(listOfFiles.get(i)), fileEncoding);
								BufferedReader br = new BufferedReader(fstream);
								try {
									int lineNum = 1;
									// skip the first line if indicated via the configuration
									if(skipFirstLine){
										br.readLine();
										lineNum++;
									}
									IContext newContext =getContext();//.getSession().createContext();
									newContext.startTransaction();
									logger.debug("Start import");
									while ((strLine = br.readLine()) != null)   {

										lineNum++;
										logger.trace("reading line "+ (lineNum-1));
										/* Process the columns for the current file and create column objects
										 * Column objects are stored in a list to relate to the line object
										 * If file uses text qualifier split the columns while taking into account
										 * that all data between the qualifiers is a column,
										 * else just split based on the delimiter
										 */
										if(interfaceDefinition.getTextQualifierSelection().toString()== "None" || interfaceDefinition.getDelimiter().length() > 1){
											splitarray = strLine.split(Delimiter, -1);
										}
										else if(interfaceDefinition.getDelimiter().length() == 1 && interfaceDefinition.getTextQualifierSelection().toString() != "None") {
											splitarray = SplitWithTextQualifier(strLine, interfaceDefinition.getTextQualifierSelection().toString(), interfaceDefinition.getDelimiter());
										}
										if (splitarray.length == columnList.size()){
											Shared.CreateEntity(interfaceDefinition.getMappedEntity(newContext), interfaceDefinition.getTriggerEventsOnCommit(newContext), splitarray, columnList,String.valueOf(lineNum-1), newContext, logObject, importedObjects, logToConsole, logObj);
										}
										else{
											LogMsg logMsg = logObj.getMsgByID(1);
											logMsg.setLines(lineNum-1);
										}

										if (importedObjects.size()>batchSize) {
											Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
										}
									}
									if (importedObjects.size()> 0) {
										Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
									}
									logger.debug("End import");
									newContext.endTransaction();
									br.close();
									/* Rename the processed file by adding a datetimestamp to the extension
									 * This will make the processed files unique
									 */
									if(renameFile){
										Shared.changeFileExtension(file,RENAME_EXTENSION, logObject, newContext, logToConsole);
									}
									fstream.close();
									/*
									 * Log errors if existing
									 */
									lf.WriteLogs(logObj, logObject, context, logToConsole, logger);
								} catch (Exception e) {
									try {
										Shared.CreateLogMessage(LogMessageType.Error, "General in the method", e.getMessage(),logObject, context,logToConsole);
									} catch (CoreException ec) {
										ec.printStackTrace();
									}
								} finally{
									if(br != null){
										br.close();
									}
									if(fstream != null){
										fstream.close();
									}
								}
							} 
						}

					}
					else{
						try {
							Shared.CreateLogMessage(LogMessageType.Warning, "No files found in "+importDirectory+" with file extension "+ fileExtension, "",logObject, getContext(),logToConsole);
						} catch (CoreException e) {
							e.printStackTrace();
						}
					}
				}
				else{
					try {
						Shared.CreateLogMessage(LogMessageType.Error, "Import directory "+importDirectory+" not found", "",logObject, context,logToConsole);
					} catch (CoreException e) {
						e.printStackTrace();
					}
				}
			} catch (Exception e) {
				try {
					Shared.CreateLogMessage(LogMessageType.Error, "General error on reading files", e.getMessage(),logObject, context,logToConsole);
				} catch (CoreException ec) {
					ec.printStackTrace();
				}
			}
		}
		else{
			try {
				String strLine;
				String splitarray[] = null;
				//Start processing the files from the list
				for (int i = 0; i < inputQueuedFiles.size(); i++) {
					ProcesFileQueue file = inputQueuedFiles.get(i);
					InputStream fstream = Core.getFileDocumentContent(context, file.getMendixObject());
					BufferedReader br = new BufferedReader(new InputStreamReader(fstream));
					try {
						int lineNum = 1;
						// skip the first line if indicated via the configuration
						if(skipFirstLine){
							br.readLine();
							lineNum++;
						}

						IContext newContext =getContext().getSession().createContext();
						newContext.startTransaction();
						logger.debug("Start import");
						while ((strLine = br.readLine()) != null)   {
							lineNum++;
							logger.trace("reading line "+ (lineNum-1));
							/* Process the columns for the current file and create column objects
							 * Column objects are stored in a list to relate to the line object
							 * If file uses text qualifier split the columns while taking into account
							 * that all data between the qualifiers is a column,
							 * else just split based on the delimiter
							 */
							if(interfaceDefinition.getTextQualifierSelection().toString()== "None" || interfaceDefinition.getDelimiter().length() > 1){
								splitarray = strLine.split(Delimiter, -1);
							}
							else if(interfaceDefinition.getDelimiter().length() == 1 && interfaceDefinition.getTextQualifierSelection().toString() != "None") {
								splitarray = SplitWithTextQualifier(strLine, interfaceDefinition.getTextQualifierSelection().toString(), interfaceDefinition.getDelimiter());
							}
							if (splitarray.length == columnList.size()){

								Shared.CreateEntity(interfaceDefinition.getMappedEntity(newContext), interfaceDefinition.getTriggerEventsOnCommit(newContext), splitarray, columnList,String.valueOf(lineNum-1), newContext, logObject, importedObjects, logToConsole, logObj);

							}
							else{
								try {
									LogMsg logMsg = logObj.getMsgByID(1);
									logMsg.setLines(lineNum-1);
									file.setError(true);
									file.commit();
								} catch (CoreException e) {
									e.printStackTrace();
								}
							}
							if (importedObjects.size()>batchSize) {
								Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
							}
						}
						if (importedObjects.size()> 0) {
							Shared.commitAndClearList(importedObjects, triggerEvents, newContext);
						}
						logger.debug("End import");
						newContext.endTransaction();
						br.close();
						/* 
						 * Set the processed file as processed
						 */
						file.setProcessed(true);
						file.commit();
						fstream.close();
						/*
						 * Log errors if existing
						 */
						lf.WriteLogs(logObj, logObject, context, logToConsole, logger);

					} catch (Exception e) {
						try {
							Shared.CreateLogMessage(LogMessageType.Error, "General in the method", e.getMessage(),logObject, context,logToConsole);
						} catch (CoreException ec) {
							ec.printStackTrace();
						}
					} finally{
						if(br != null){
							br.close();
						}
						if(fstream != null){
							fstream.close();
						}
					}
				}

			} catch (Exception e) {
				try {
					Shared.CreateLogMessage(LogMessageType.Error, "General error on reading queued files", e.getMessage(),logObject, getContext(),logToConsole);
				} catch (CoreException ec) {
					ec.printStackTrace();
				}
			} 

		}
		return uID;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "ExecuteInterface_Delimited_4_1_00";
	}

	// BEGIN EXTRA CODE

	private static final String RENAME_EXTENSION = "bak";
	private static final String LOGNODE = "FFI Import";

	/**
	 * Function to split a line from a text file with delimiters with the use of text qualifiers
	 * Used when content can contain the delimiter: e.g. "a,b","a" should result in 2 strings a,b and a
	 * 
	 * @param input the line from the file
	 * @param textQualifier the qualifier use for strings
	 * @param delimiter that separates the columns in the line
	 * @return String array
	 */

	private String[] SplitWithTextQualifier(String input, String textQualifier, String delimiter){
		String[] returnArray = null;
		List<String> elements = new ArrayList<String>();       
		StringBuilder elementBuilder = new StringBuilder();
		//get the textqualifier as char variable
		char qualifierChar = 0;	
		if(textQualifier == "Single_Quote___"){
			qualifierChar ='\'';
		}
		else if (textQualifier == "Double_Quote___"){
			qualifierChar ='\"';
		}
		boolean isQuoted = false;
		//read characters and add to elementbuilder until delimiter is found outside the textqualifiers
		for (char c : input.toCharArray()) {
			if (c == qualifierChar) {
				isQuoted = !isQuoted;
			}
			if (c == delimiter.charAt(0) && !isQuoted) {
				elements.add(elementBuilder.toString().trim());
				elementBuilder = new StringBuilder();
				continue;
			}
			if(c != qualifierChar){
				elementBuilder.append(c);
			}
		}
		elements.add(elementBuilder.toString().trim());
		//Move strings from list to array
		for(int i=0;i<elements.size();i++){
			returnArray = (String[]) elements.toArray(new String[i]);
		}
		return returnArray;
	}
	// END EXTRA CODE
}
